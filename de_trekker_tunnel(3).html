<!DOCTYPE html>
<html lang="nl">
<head>
<meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1.0">
<title>De Trekker</title>
<style>
  @import url('https://fonts.googleapis.com/css2?family=EB+Garamond:ital,wght@0,400;0,500;0,600;1,400');

  * { margin: 0; padding: 0; box-sizing: border-box; }

  body {
    background: #ffffff;
    color: #1a1a1a;
    font-family: 'EB Garamond', Georgia, serif;
    overflow-x: hidden;
    min-height: 100vh;
  }

  .page {
    max-width: 700px;
    margin: 0 auto;
    padding: 50px 30px 0;
    margin-bottom: 120px;
  }

  .opening {
    font-size: 1.25em;
    line-height: 1.85;
    font-weight: 400;
    color: #1a1a1a;
  }

  .tunnel-viewport {
    position: relative;
    width: 100%;
    height: 100vh;
    overflow: hidden;
    cursor: default;
    background: #ffffff;
    /* Prevent pull-to-refresh on mobile */
    touch-action: none;
  }

  canvas#tunnelCanvas {
    position: absolute;
    top: 0;
    left: 0;
    width: 100%;
    height: 100%;
    z-index: 1;
  }

  .poem-line {
    position: absolute;
    white-space: nowrap;
    font-family: 'EB Garamond', Georgia, serif;
    font-weight: 400;
    letter-spacing: 0.01em;
    pointer-events: none;
    opacity: 0;
    z-index: 10;
    color: #1a1a1a;
  }

  #poem-lines-container {
    position: absolute;
    top: 0;
    left: 0;
    width: 100%;
    height: 100%;
    z-index: 10;
  }

  .pause-indicator {
    position: absolute;
    bottom: 15px;
    left: 50%;
    transform: translateX(-50%);
    font-family: 'EB Garamond', Georgia, serif;
    font-size: 0.8em;
    color: #ccc;
    font-style: italic;
    opacity: 0;
    transition: opacity 0.5s ease;
    z-index: 50;
    pointer-events: none;
  }

  .show-pause .pause-indicator {
    opacity: 1;
  }

  /* ── MOBILE ── */
  @media (max-width: 768px) {
    .page {
      padding: 30px 20px 0;
      margin-bottom: 80px;
    }
    .opening {
      font-size: 1.1em;
      line-height: 1.75;
    }
    .tunnel-viewport {
      height: 80vh;
    }
  }

  @media (max-width: 480px) {
    .page {
      padding: 24px 16px 0;
      margin-bottom: 60px;
    }
    .opening {
      font-size: 1em;
      line-height: 1.7;
    }
    .tunnel-viewport {
      height: 75vh;
    }
  }
</style>
</head>
<body>

<div class="page">
  <div class="opening">
    Ik wil niet meer<br>
    zei hij zonder zelfmedelijden<br>
    want zelfmedelijden is voor zwakkelingen<br>
    en hij haalde de trekker over:
  </div>
</div>

<div class="tunnel-viewport" id="tunnel">
  <canvas id="tunnelCanvas"></canvas>
  <div id="poem-lines-container"></div>
  <div class="pause-indicator">&mdash; gepauzeerd &mdash;</div>
</div>

<script>
  var canvas = document.getElementById('tunnelCanvas');
  var ctx = canvas.getContext('2d');
  var tunnelEl = document.getElementById('tunnel');

  function resizeCanvas() {
    canvas.width = tunnelEl.clientWidth;
    canvas.height = tunnelEl.clientHeight;
  }
  resizeCanvas();
  window.addEventListener('resize', resizeCanvas);

  // ── Stardust (sparse) ──
  var stars = [];
  for (var i = 0; i < 12; i++) {
    stars.push({
      angle: Math.random() * Math.PI * 2,
      dist: Math.random(),
      speed: 0.0008 + Math.random() * 0.003,
      size: 0.4 + Math.random() * 1.2,
      brightness: 0.3 + Math.random() * 0.5,
      twinkleSpeed: 0.4 + Math.random() * 1.5,
      twinkleOffset: Math.random() * Math.PI * 2
    });
  }

  // ── Planets ──
  var planets = [];
  var planetColors = [
    {r: 160, g: 155, b: 148},
    {r: 130, g: 135, b: 140},
    {r: 150, g: 140, b: 135}
  ];
  var lastPlanetTime = 0;
  var planetInterval = 18000;

  function spawnPlanet(now) {
    var col = planetColors[Math.floor(Math.random() * planetColors.length)];
    planets.push({
      angle: Math.random() * Math.PI * 2,
      dist: 0,
      speed: 0.0005 + Math.random() * 0.0007,
      baseSize: 1.5 + Math.random() * 3,
      color: col,
      hasRing: Math.random() > 0.6
    });
  }

  var isPaused = false;

  // ── Tunnel center: positioned slightly above true center ──
  // This gives more room for lines going downward
  function getCenter() {
    return {
      x: canvas.width / 2,
      y: canvas.height * 0.42
    };
  }

  function drawTunnel(now) {
    var w = canvas.width;
    var h = canvas.height;
    var c = getCenter();
    var cx = c.x;
    var cy = c.y;
    var maxR = Math.max(w, h) * 0.8;

    ctx.fillStyle = '#ffffff';
    ctx.fillRect(0, 0, w, h);

    // Tunnel rings
    var numRings = 25;
    for (var i = 0; i < numRings; i++) {
      var t = i / (numRings - 1);
      var perspT = Math.pow(t, 2.2);
      var radius = 5 + perspT * maxR;
      var opacity = 0.03 + t * 0.07;

      ctx.beginPath();
      ctx.arc(cx, cy, radius, 0, Math.PI * 2);
      ctx.closePath();
      ctx.strokeStyle = 'rgba(0, 0, 0, ' + opacity + ')';
      ctx.lineWidth = 0.4 + t * 1.2;
      ctx.stroke();
    }

    // Pulsating center
    var pulse = 0.7 + 0.3 * Math.sin(now * 0.002);
    var pulse2 = 0.8 + 0.2 * Math.sin(now * 0.003 + 1);

    var outerGlow = ctx.createRadialGradient(cx, cy, 0, cx, cy, 40 * pulse2);
    outerGlow.addColorStop(0, 'rgba(0, 0, 0, ' + (0.08 * pulse) + ')');
    outerGlow.addColorStop(0.5, 'rgba(0, 0, 0, ' + (0.03 * pulse) + ')');
    outerGlow.addColorStop(1, 'rgba(0, 0, 0, 0)');
    ctx.fillStyle = outerGlow;
    ctx.beginPath();
    ctx.arc(cx, cy, 40 * pulse2, 0, Math.PI * 2);
    ctx.fill();

    ctx.beginPath();
    ctx.arc(cx, cy, 4 + 2 * pulse, 0, Math.PI * 2);
    ctx.fillStyle = 'rgba(0, 0, 0, ' + (0.15 * pulse) + ')';
    ctx.fill();

    ctx.beginPath();
    ctx.arc(cx, cy, 1.5, 0, Math.PI * 2);
    ctx.fillStyle = 'rgba(0, 0, 0, 0.3)';
    ctx.fill();

    if (!isPaused) {
      for (var s = 0; s < stars.length; s++) {
        stars[s].dist += stars[s].speed;
        if (stars[s].dist > 1.1) {
          stars[s].dist = 0;
          stars[s].angle = Math.random() * Math.PI * 2;
          stars[s].speed = 0.0008 + Math.random() * 0.003;
        }
      }
      if (now - lastPlanetTime > planetInterval) {
        spawnPlanet(now);
        lastPlanetTime = now;
        planetInterval = 15000 + Math.random() * 12000;
      }
      for (var p = planets.length - 1; p >= 0; p--) {
        planets[p].dist += planets[p].speed;
        if (planets[p].dist > 1.1) planets.splice(p, 1);
      }
    }

    // Draw stars
    for (var s = 0; s < stars.length; s++) {
      var star = stars[s];
      var perspD = Math.pow(star.dist, 1.8);
      var sx = cx + Math.cos(star.angle) * perspD * maxR;
      var sy = cy + Math.sin(star.angle) * perspD * maxR;
      var sz = star.size * (0.2 + star.dist * 2.5);
      var twinkle = 0.5 + 0.5 * Math.sin(now * 0.001 * star.twinkleSpeed + star.twinkleOffset);
      var sAlpha = star.brightness * twinkle * (0.3 + star.dist * 0.7);
      if (star.dist < 0.05) sAlpha *= star.dist / 0.05;
      if (star.dist > 0.9) sAlpha *= (1.1 - star.dist) / 0.2;
      ctx.beginPath();
      ctx.arc(sx, sy, sz, 0, Math.PI * 2);
      ctx.fillStyle = 'rgba(0, 0, 0, ' + (sAlpha * 0.5) + ')';
      ctx.fill();
    }

    // Draw planets
    for (var p = 0; p < planets.length; p++) {
      var pl = planets[p];
      var perspD = Math.pow(pl.dist, 1.8);
      var px = cx + Math.cos(pl.angle) * perspD * maxR;
      var py = cy + Math.sin(pl.angle) * perspD * maxR;
      var pSize = pl.baseSize * (0.3 + pl.dist * 3);
      var pAlpha = 0.15 + pl.dist * 0.4;
      if (pl.dist < 0.05) pAlpha *= pl.dist / 0.05;
      if (pl.dist > 0.9) pAlpha *= (1.1 - pl.dist) / 0.2;

      var pg = ctx.createRadialGradient(px - pSize * 0.3, py - pSize * 0.3, 0, px, py, pSize);
      pg.addColorStop(0, 'rgba(120,120,120,' + (pAlpha * 0.5) + ')');
      pg.addColorStop(0.7, 'rgba(80,80,80,' + (pAlpha * 0.7) + ')');
      pg.addColorStop(1, 'rgba(50,50,50,' + (pAlpha * 0.3) + ')');
      ctx.beginPath();
      ctx.arc(px, py, pSize, 0, Math.PI * 2);
      ctx.fillStyle = pg;
      ctx.fill();

      if (pl.hasRing && pSize > 2.5) {
        ctx.beginPath();
        ctx.ellipse(px, py, pSize * 2, pSize * 0.4, 0.3, 0, Math.PI * 2);
        ctx.strokeStyle = 'rgba(80,80,80,' + (pAlpha * 0.3) + ')';
        ctx.lineWidth = 0.4 + pl.dist * 0.5;
        ctx.stroke();
      }
    }

    requestAnimationFrame(drawTunnel);
  }
  requestAnimationFrame(drawTunnel);

  // ========================================
  // POEM LINES - corrected from PDF
  // ========================================
  var lines = [
    "Z'n naam was mooi, z'n naam was blauw",
    "Ik zag duivels waar ze niet waren, ik zag schade waar ze niet was",
    "Wat je voelt is goed, zolang je voelt",
    "Je pikt je eigen grootheid in",
    "Ik heb de nacht weer overleefd en groet de dag",
    "Praat je uit je hoofd of uit je hart als je me zegt dat je me leuk vind?",
    "Ik rookte mijn liefde weg",
    "Het moeten voorbij",
    "Geef nooit je geheim prijs, want dat geheim ben jezelf",
    "De reis naar binnen is begonnen",
    "Ik ben tegen mezelf kapot gelopen in deze stad",
    "Wijs en waarachtig",
    "Stel dat er kinderen rondlopen die gedachten kunnen lezen",
    "Heb je je hart in eigen hand?",
    "Als de driften hoogtij vieren worden de vrouwen gekneveld en de katten gezakt",
    "Zoveel mooie vrouwen; zij betalen 's nachts hun minnaar terug",
    "Kijk en zie een orgie. Kijk niet, en zie de leegte ervan",
    "Ongerichte seksuele verlangens, alle banden los.",
    "Toeval is slechts een naam die wij gegeven hebben aan iets wat wij niet begrijpen",
    "Schuld naar de wereld, het hoeft niet.",
    "Er zit nog een boel ziekte in mijn buik.",
    "Mijn ziel bedenkt iets, mijn hoofd gaat ermee aan de loop. Weer een gedicht verprutst.",
    "Al die tijd had ik gelijk",
    "De regie wordt gewisseld",
    "Baas in eigen hoofd.",
    "Is het toeval dat latent en talent dezelfde letters bevatten?",
    "Diplomaten kunnen overal overleven, maar kunnen zij ook overal leven?",
    "Heb je je hart in eigen hand?",
    "Ik heb gezegd, ik heb gezondigd",
    "Het leven gaat zoals het gaat. Bij mij ging het zoals het ging."
  ];

  var container = document.getElementById('poem-lines-container');
  var currentLine = 0;
  var isMobile = window.matchMedia('(max-width: 768px)').matches;

  // ── Pause: hover on desktop, tap on mobile ──
  tunnelEl.addEventListener('mouseenter', function() {
    isPaused = true;
    tunnelEl.classList.add('show-pause');
  });
  tunnelEl.addEventListener('mouseleave', function() {
    isPaused = false;
    tunnelEl.classList.remove('show-pause');
  });

  // Mobile: tap to toggle pause
  var touchPaused = false;
  tunnelEl.addEventListener('touchstart', function(e) {
    e.preventDefault();
    touchPaused = !touchPaused;
    isPaused = touchPaused;
    if (isPaused) {
      tunnelEl.classList.add('show-pause');
    } else {
      tunnelEl.classList.remove('show-pause');
    }
  }, { passive: false });

  // ── Random direction biased for readability ──
  // Lines go mostly LEFT or RIGHT with slight vertical offset
  // This ensures they stay readable on all screen sizes
  function getRandomDirection() {
    // Pick a side: left or right dominant
    var goRight = Math.random() > 0.5;
    var xSign = goRight ? 1 : -1;

    // Strong horizontal, mild vertical
    var xStrength = 0.25 + Math.random() * 0.15;
    var yStrength = (Math.random() - 0.5) * 0.2; // can go slightly up or down

    return {
      xOffset: xSign * xStrength,
      yOffset: yStrength
    };
  }

  function animateLine(index) {
    var lineIndex = index % lines.length;
    var text = lines[lineIndex];
    var el = document.createElement('div');
    el.className = 'poem-line';
    el.textContent = text;
    container.appendChild(el);

    var dir = getRandomDirection();
    var viewW = tunnelEl.clientWidth;
    var viewH = tunnelEl.clientHeight;
    var c = getCenter();
    var centerX = c.x;
    var centerY = c.y;

    // Compute direction vector and extend far off screen
    var dirLen = Math.sqrt(dir.xOffset * dir.xOffset + dir.yOffset * dir.yOffset);
    var endX = centerX + (dir.xOffset / dirLen) * viewW * 1.5;
    var endY = centerY + (dir.yOffset / dirLen) * viewH * 1.5;

    var duration = isMobile ? 6500 : 8000;
    var startTime = null;
    var pausedAt = null;
    var totalPausedTime = 0;
    var startFontSize = isMobile ? 1 : 1;
    var endFontSize = isMobile ? (70 + Math.random() * 40) : (120 + Math.random() * 60);

    el.style.left = centerX + 'px';
    el.style.top = centerY + 'px';
    el.style.fontSize = startFontSize + 'px';
    el.style.transform = 'translate(-50%, -50%)';

    function step(now) {
      if (isPaused) {
        if (pausedAt === null) pausedAt = now;
        requestAnimationFrame(step);
        return;
      } else if (pausedAt !== null) {
        totalPausedTime += now - pausedAt;
        pausedAt = null;
      }

      if (startTime === null) startTime = now;
      var elapsed = now - startTime - totalPausedTime;
      var rawT = Math.min(elapsed / duration, 1);
      var t = rawT * rawT * rawT;

      var x = centerX + (endX - centerX) * t;
      var y = centerY + (endY - centerY) * t;
      var fontSize = startFontSize + (endFontSize - startFontSize) * t;

      var opacity = rawT < 0.1 ? rawT / 0.1 : 1;
      var grey = Math.round(180 - rawT * 154);

      el.style.left = x + 'px';
      el.style.top = y + 'px';
      el.style.fontSize = fontSize + 'px';
      el.style.opacity = Math.max(0, opacity);
      el.style.color = 'rgb(' + grey + ',' + grey + ',' + grey + ')';

      if (rawT < 1) {
        requestAnimationFrame(step);
      } else {
        if (el.parentNode) el.parentNode.removeChild(el);
      }
    }
    requestAnimationFrame(step);
  }

  function startSequence() {
    if (isPaused) {
      setTimeout(startSequence, 100);
      return;
    }
    animateLine(currentLine);
    currentLine++;
    var delay = isMobile ? (2500 + Math.random() * 800) : (3000 + Math.random() * 1200);
    setTimeout(startSequence, delay);
  }

  // Auto-start after 1 second
  setTimeout(startSequence, 1000);
</script>

</body>
</html>
