<!DOCTYPE html>
<html lang="nl">
<head>
<meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1.0">
<title>De Trekker</title>
<style>
  * { margin: 0; padding: 0; box-sizing: border-box; }

  body {
    background: #ffffff;
    color: #000000;
    font-family: times, Helvetica, Courier, sans-serif;
    overflow: hidden;
    height: 100vh;
    width: 100vw;
    line-height: 150%;
  }

  .wrapper {
    display: flex;
    flex-direction: column;
    height: 100vh;
    width: 100vw;
  }

  .opening {
    font-size: 21px;
    font-weight: normal;
    color: black;
    padding-top: 94px;
    padding-left: 105px;
    flex-shrink: 0;
  }

  /* ═══ DESKTOP: tunnel ═══ */
  .tunnel-viewport {
    position: relative;
    flex: 1;
    overflow: hidden;
    background: #ffffff;
    margin-top: 60px;
    min-height: 0;
    touch-action: none;
  }

  canvas#tunnelCanvas {
    position: absolute;
    top: 0; left: 0;
    width: 100%; height: 100%;
    z-index: 1;
  }

  .poem-line {
    position: absolute;
    white-space: pre;
    font-family: times, Helvetica, Courier, sans-serif;
    font-weight: normal;
    pointer-events: none;
    opacity: 0;
    z-index: 10;
    color: #000000;
    line-height: 130%;
  }

  #poem-lines-container {
    position: absolute;
    top: 0; left: 0;
    width: 100%; height: 100%;
    z-index: 10;
  }

  .pause-indicator {
    position: absolute;
    bottom: 12px;
    left: 50%;
    transform: translateX(-50%);
    font-size: 14px;
    color: #ccc;
    font-style: italic;
    opacity: 0;
    transition: opacity 0.5s ease;
    z-index: 50;
    pointer-events: none;
  }

  .show-pause .pause-indicator { opacity: 1; }

  /* ═══ MOBILE: hide tunnel, show simple area ═══ */
  .mobile-poem-area { display: none; }

  @media screen and (max-width: 600px) {
    .opening {
      padding-top: 40px;
      padding-left: 20px;
      padding-right: 20px;
      font-size: 18px;
    }
    body { line-height: 130%; }

    .tunnel-viewport { display: none; }

    .mobile-poem-area {
      display: block;
      position: relative;
      flex: 1;
      overflow: hidden;
      margin-top: 20px;
      min-height: 0;
      touch-action: none;
    }

    .mobile-line {
      position: absolute;
      font-family: times, Helvetica, Courier, sans-serif;
      font-weight: normal;
      color: #000000;
      opacity: 0;
      pointer-events: none;
      white-space: pre;
      line-height: 130%;
    }

    .mobile-pause-indicator {
      position: absolute;
      bottom: 12px;
      left: 50%;
      transform: translateX(-50%);
      font-size: 14px;
      color: #ccc;
      font-style: italic;
      opacity: 0;
      transition: opacity 0.5s ease;
      pointer-events: none;
    }

    .mobile-poem-area.show-pause .mobile-pause-indicator { opacity: 1; }
  }
</style>
</head>
<body>

<div class="wrapper">
  <div class="opening">
    Ik wil niet meer<br>
    zei hij zonder zelfmedelijden<br>
    want zelfmedelijden is voor zwakkelingen<br>
    en hij haalde de trekker over:
  </div>

  <!-- DESKTOP -->
  <div class="tunnel-viewport" id="tunnel">
    <canvas id="tunnelCanvas"></canvas>
    <div id="poem-lines-container"></div>
    <div class="pause-indicator">&mdash; gepauzeerd &mdash;</div>
  </div>

  <!-- MOBILE -->
  <div class="mobile-poem-area" id="mobileArea">
    <div class="mobile-pause-indicator">&mdash; gepauzeerd &mdash;</div>
  </div>
</div>

<script>
  var lines = [
    "Z'n naam was mooi, z'n naam was blauw",
    "Ik zag duivels waar ze niet waren,\nik zag schade waar ze niet was",
    "Wat je voelt is goed, zolang je voelt",
    "Je pikt je eigen grootheid in",
    "Ik heb de nacht weer overleefd\nen groet de dag",
    "Praat je uit je hoofd of uit je hart\n als je me zegt dat je me leuk vind?",
    "Ik rookte mijn liefde weg",
    "Het moeten voorbij",
    "Geef nooit je geheim prijs,\n want dat geheim ben jezelf",
    "De reis naar binnen is begonnen",
    "Ik ben tegen mezelf kapot gelopen in deze stad",
    "Wijs en waarachtig",
    "Stel dat er kinderen rondlopen\ndie gedachten kunnen lezen",
    "Heb je je hart in eigen hand?",
    "Als de driften hoogtij vieren\nworden de vrouwen gekneveld\nen de katten gezakt",
    "Zoveel mooie vrouwen;\nzij betalen 's nachts hun minnaar terug",
    "Kijk en zie een orgie.\nKijk niet, en zie de leegte ervan",
    "Ongerichte seksuele verlangens, alle banden los.",
    "Toeval is slechts een naam\ndie wij gegeven hebben aan iets\nwat wij niet begrijpen",
    "Schuld naar de wereld, het hoeft niet.",
    "Er zit nog een boel ziekte in mijn buik.",
    "Mijn ziel bedenkt iets,\nmijn hoofd gaat ermee aan de loop.\nWeer een gedicht verprutst.",
    "Al die tijd had ik gelijk",
    "De regie wordt gewisseld",
    "Baas in eigen hoofd.",
    "Is het toeval dat latent en talent\ndezelfde letters bevatten?",
    "Diplomaten kunnen overal overleven,\nmaar kunnen zij ook overal leven?",
    "Heb je je hart in eigen hand?",
    "Ik heb gezegd, ik heb gezondigd",
    "Het leven gaat zoals het gaat.\nBij mij ging het zoals het ging."
  ];

  var isMobile = window.innerWidth <= 600;

  if (isMobile) {
    // ════════════════════════════════════════
    // MOBILE: fade in/out at random positions
    // ════════════════════════════════════════
    var mobileArea = document.getElementById('mobileArea');
    var mCurrentLine = 0;
    var mPaused = false;

    mobileArea.addEventListener('touchstart', function(e) {
      e.preventDefault();
      mPaused = !mPaused;
      if (mPaused) mobileArea.classList.add('show-pause');
      else mobileArea.classList.remove('show-pause');
    }, { passive: false });

    function showMobileLine() {
      if (mPaused) { setTimeout(showMobileLine, 200); return; }

      var idx = mCurrentLine % lines.length;
      mCurrentLine++;

      var el = document.createElement('div');
      el.className = 'mobile-line';
      el.textContent = lines[idx];
      mobileArea.appendChild(el);

      var areaW = mobileArea.clientWidth;
      var areaH = mobileArea.clientHeight;

      // Font size: subtle variation
      var fontSize = 15 + Math.random() * 4;
      el.style.fontSize = fontSize + 'px';

      // Grey value: vary for depth
      var grey = Math.round(20 + Math.random() * 100);
      el.style.color = 'rgb(' + grey + ',' + grey + ',' + grey + ')';

      // Place element to measure it
      el.style.opacity = '0';
      el.style.left = '0px';
      el.style.top = '0px';
      var textH = el.offsetHeight || 40;

      // Random position, keep within bounds
      var left = 15 + Math.random() * (areaW * 0.3);
      var top = 10 + Math.random() * Math.max(10, areaH - textH - 20);
      el.style.left = left + 'px';
      el.style.top = top + 'px';

      // Animate: fade in, hold, fade out
      var fadeIn = 1000, hold = 3000, fadeOut = 1000;
      var total = fadeIn + hold + fadeOut;
      var startTime = null;
      var pausedAt = null, totalPausedTime = 0;

      function animate(now) {
        if (mPaused) {
          if (pausedAt === null) pausedAt = now;
          requestAnimationFrame(animate);
          return;
        } else if (pausedAt !== null) {
          totalPausedTime += now - pausedAt;
          pausedAt = null;
        }
        if (startTime === null) startTime = now;
        var elapsed = now - startTime - totalPausedTime;

        if (elapsed < fadeIn) {
          el.style.opacity = (elapsed / fadeIn).toString();
        } else if (elapsed < fadeIn + hold) {
          el.style.opacity = '1';
        } else if (elapsed < total) {
          el.style.opacity = (1 - (elapsed - fadeIn - hold) / fadeOut).toString();
        } else {
          if (el.parentNode) el.parentNode.removeChild(el);
          return;
        }
        requestAnimationFrame(animate);
      }
      requestAnimationFrame(animate);

      // Next line after a staggered delay
      setTimeout(showMobileLine, 3500 + Math.random() * 2000);
    }

    setTimeout(showMobileLine, 1000);

  } else {
    // ════════════════════════════════════════
    // DESKTOP: full canvas tunnel
    // ════════════════════════════════════════
    var canvas = document.getElementById('tunnelCanvas');
    var ctx = canvas.getContext('2d');
    var tunnelEl = document.getElementById('tunnel');

    function resizeCanvas() {
      canvas.width = tunnelEl.clientWidth;
      canvas.height = tunnelEl.clientHeight;
    }
    resizeCanvas();
    window.addEventListener('resize', resizeCanvas);

    var stars = [];
    for (var i = 0; i < 12; i++) {
      stars.push({
        angle: Math.random() * Math.PI * 2, dist: Math.random(),
        speed: 0.0008 + Math.random() * 0.003,
        size: 0.4 + Math.random() * 1.2,
        brightness: 0.3 + Math.random() * 0.5,
        twinkleSpeed: 0.4 + Math.random() * 1.5,
        twinkleOffset: Math.random() * Math.PI * 2
      });
    }

    var planets = [];
    var planetColors = [{r:160,g:155,b:148},{r:130,g:135,b:140},{r:150,g:140,b:135}];
    var lastPlanetTime = 0, planetInterval = 18000;

    function spawnPlanet(now) {
      var col = planetColors[Math.floor(Math.random() * planetColors.length)];
      planets.push({
        angle: Math.random() * Math.PI * 2, dist: 0,
        speed: 0.0005 + Math.random() * 0.0007,
        baseSize: 1.5 + Math.random() * 3, color: col,
        hasRing: Math.random() > 0.6
      });
    }

    var isPaused = false;

    function getCenter() { return { x: canvas.width / 2, y: canvas.height * 0.45 }; }

    function drawTunnel(now) {
      var w = canvas.width, h = canvas.height;
      var c = getCenter(), cx = c.x, cy = c.y;
      var maxR = Math.max(w, h) * 0.8;

      ctx.fillStyle = '#fff';
      ctx.fillRect(0, 0, w, h);

      for (var i = 0; i < 25; i++) {
        var t = i / 24, perspT = Math.pow(t, 2.2);
        var radius = 5 + perspT * maxR;
        ctx.beginPath();
        ctx.arc(cx, cy, radius, 0, Math.PI * 2);
        ctx.closePath();
        ctx.strokeStyle = 'rgba(0,0,0,' + (0.03 + t * 0.07) + ')';
        ctx.lineWidth = 0.4 + t * 1.2;
        ctx.stroke();
      }

      var pulse = 0.7 + 0.3 * Math.sin(now * 0.002);
      var pulse2 = 0.8 + 0.2 * Math.sin(now * 0.003 + 1);
      var g = ctx.createRadialGradient(cx, cy, 0, cx, cy, 40 * pulse2);
      g.addColorStop(0, 'rgba(0,0,0,' + (0.08 * pulse) + ')');
      g.addColorStop(0.5, 'rgba(0,0,0,' + (0.03 * pulse) + ')');
      g.addColorStop(1, 'rgba(0,0,0,0)');
      ctx.fillStyle = g;
      ctx.beginPath(); ctx.arc(cx, cy, 40 * pulse2, 0, Math.PI * 2); ctx.fill();
      ctx.beginPath(); ctx.arc(cx, cy, 4 + 2 * pulse, 0, Math.PI * 2);
      ctx.fillStyle = 'rgba(0,0,0,' + (0.15 * pulse) + ')'; ctx.fill();
      ctx.beginPath(); ctx.arc(cx, cy, 1.5, 0, Math.PI * 2);
      ctx.fillStyle = 'rgba(0,0,0,0.3)'; ctx.fill();

      if (!isPaused) {
        for (var s = 0; s < stars.length; s++) {
          stars[s].dist += stars[s].speed;
          if (stars[s].dist > 1.1) {
            stars[s].dist = 0; stars[s].angle = Math.random() * Math.PI * 2;
            stars[s].speed = 0.0008 + Math.random() * 0.003;
          }
        }
        if (now - lastPlanetTime > planetInterval) {
          spawnPlanet(now); lastPlanetTime = now;
          planetInterval = 15000 + Math.random() * 12000;
        }
        for (var p = planets.length - 1; p >= 0; p--) {
          planets[p].dist += planets[p].speed;
          if (planets[p].dist > 1.1) planets.splice(p, 1);
        }
      }

      for (var s = 0; s < stars.length; s++) {
        var st = stars[s], pd = Math.pow(st.dist, 1.8);
        var sx = cx + Math.cos(st.angle) * pd * maxR;
        var sy = cy + Math.sin(st.angle) * pd * maxR;
        var sz = st.size * (0.2 + st.dist * 2.5);
        var tw = 0.5 + 0.5 * Math.sin(now * 0.001 * st.twinkleSpeed + st.twinkleOffset);
        var sa = st.brightness * tw * (0.3 + st.dist * 0.7);
        if (st.dist < 0.05) sa *= st.dist / 0.05;
        if (st.dist > 0.9) sa *= (1.1 - st.dist) / 0.2;
        ctx.beginPath(); ctx.arc(sx, sy, sz, 0, Math.PI * 2);
        ctx.fillStyle = 'rgba(0,0,0,' + (sa * 0.5) + ')'; ctx.fill();
      }

      for (var p = 0; p < planets.length; p++) {
        var pl = planets[p], pd = Math.pow(pl.dist, 1.8);
        var px = cx + Math.cos(pl.angle) * pd * maxR;
        var py = cy + Math.sin(pl.angle) * pd * maxR;
        var ps = pl.baseSize * (0.3 + pl.dist * 3);
        var pa = 0.15 + pl.dist * 0.4;
        if (pl.dist < 0.05) pa *= pl.dist / 0.05;
        if (pl.dist > 0.9) pa *= (1.1 - pl.dist) / 0.2;
        var pg = ctx.createRadialGradient(px - ps * 0.3, py - ps * 0.3, 0, px, py, ps);
        pg.addColorStop(0, 'rgba(120,120,120,' + (pa * 0.5) + ')');
        pg.addColorStop(0.7, 'rgba(80,80,80,' + (pa * 0.7) + ')');
        pg.addColorStop(1, 'rgba(50,50,50,' + (pa * 0.3) + ')');
        ctx.beginPath(); ctx.arc(px, py, ps, 0, Math.PI * 2);
        ctx.fillStyle = pg; ctx.fill();
        if (pl.hasRing && ps > 2.5) {
          ctx.beginPath();
          ctx.ellipse(px, py, ps * 2, ps * 0.4, 0.3, 0, Math.PI * 2);
          ctx.strokeStyle = 'rgba(80,80,80,' + (pa * 0.3) + ')';
          ctx.lineWidth = 0.4 + pl.dist * 0.5; ctx.stroke();
        }
      }

      requestAnimationFrame(drawTunnel);
    }
    requestAnimationFrame(drawTunnel);

    var container = document.getElementById('poem-lines-container');
    var currentLine = 0, activeCount = 0, MAX_ACTIVE = 3;

    tunnelEl.addEventListener('click', function() {
      isPaused = !isPaused;
      if (isPaused) tunnelEl.classList.add('show-pause');
      else tunnelEl.classList.remove('show-pause');
    });

    function getDir() {
      var xSign = Math.random() > 0.5 ? 1 : -1;
      return {
        xOffset: xSign * (0.25 + Math.random() * 0.15),
        yOffset: (Math.random() - 0.5) * 0.18
      };
    }

    function animateLine(index) {
      var el = document.createElement('div');
      el.className = 'poem-line';
      el.textContent = lines[index % lines.length];
      container.appendChild(el);
      activeCount++;

      var dir = getDir();
      var vW = tunnelEl.clientWidth, vH = tunnelEl.clientHeight;
      var c = getCenter(), cX = c.x, cY = c.y;
      var dL = Math.sqrt(dir.xOffset * dir.xOffset + dir.yOffset * dir.yOffset);
      var eX = cX + (dir.xOffset / dL) * vW * 1.5;
      var eY = cY + (dir.yOffset / dL) * vH * 1.5;

      var startFontSize = 8;
      var endFontSize = 120 + Math.random() * 60;
      var dur = 8000, st = null, pAt = null, pTime = 0;

      el.style.left = cX + 'px'; el.style.top = cY + 'px';
      el.style.fontSize = startFontSize + 'px';
      el.style.transform = 'translate(-50%, -50%)';
      el.style.opacity = '1';
      el.style.color = 'rgb(180,180,180)';

      function step(now) {
        if (isPaused) {
          if (pAt === null) pAt = now;
          requestAnimationFrame(step); return;
        } else if (pAt !== null) { pTime += now - pAt; pAt = null; }
        if (st === null) st = now;
        var elapsed = now - st - pTime;
        var rawT = Math.min(elapsed / dur, 1);
        var t = rawT * rawT * rawT;

        el.style.left = (cX + (eX - cX) * t) + 'px';
        el.style.top = (cY + (eY - cY) * t) + 'px';
        el.style.fontSize = (startFontSize + (endFontSize - startFontSize) * t) + 'px';
        el.style.opacity = '1';
        var gr = Math.round(180 - rawT * 154);
        el.style.color = 'rgb(' + gr + ',' + gr + ',' + gr + ')';

        if (rawT < 1) requestAnimationFrame(step);
        else { if (el.parentNode) el.parentNode.removeChild(el); activeCount--; }
      }
      requestAnimationFrame(step);
    }

    function startSeq() {
      if (isPaused || activeCount >= MAX_ACTIVE) { setTimeout(startSeq, 200); return; }
      animateLine(currentLine); currentLine++;
      setTimeout(startSeq, 3000 + Math.random() * 1200);
    }
    setTimeout(startSeq, 1000);
  }
</script>

</body>
</html>
